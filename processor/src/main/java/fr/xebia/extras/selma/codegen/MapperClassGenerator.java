/*
 * Copyright 2013 Xebia and SÃ©ven Le Mesle
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package fr.xebia.extras.selma.codegen;

import com.squareup.javawriter.JavaWriter;
import fr.xebia.extras.selma.EnumMapper;
import fr.xebia.extras.selma.Mapper;
import fr.xebia.extras.selma.SelmaConstants;

import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.element.*;
import javax.lang.model.type.TypeKind;
import javax.lang.model.type.TypeMirror;
import javax.tools.JavaFileObject;
import java.io.IOException;
import java.util.*;

import static javax.lang.model.element.Modifier.*;

/**
 *
 */
public class MapperClassGenerator {


    public static final String GENERATED_BY_SELMA = "GENERATED BY S3LM4";
    public static final Set<String> registry = new HashSet<String>();
    public static final String CUSTOM_MAPPER_FIELD_TPL = "customMapper%s";
    private final Collection<ExecutableElement> mapperMethods;
    private final String origClasse;
    private final ProcessingEnvironment processingEnv;
    private final MapperGeneratorContext context;
    private final MappingRegistry mappingRegistry;
    private final TypeElement element;
    private final SourceConfiguration configuration;
    private final List<TypeElement> customMaperFields;
    private final IgnoreFieldsWrapper ignoreFieldsWrapper;
    private final FieldsWrapper fields;
    private CustomMapperWrapper customMappers;

    public MapperClassGenerator(String classe, Collection<ExecutableElement> executableElements, ProcessingEnvironment processingEnvironment) {
        this.origClasse = classe;
        this.mapperMethods = executableElements;
        this.processingEnv = processingEnvironment;
        context = new MapperGeneratorContext(processingEnv, null);
        mappingRegistry = new MappingRegistry(context);
        customMaperFields = new LinkedList<TypeElement>();

        element = context.elements.getTypeElement(classe);

        AnnotationWrapper mapper = AnnotationWrapper.buildFor(context, element, Mapper.class);
        ignoreFieldsWrapper = new IgnoreFieldsWrapper(context, element);
        configuration = SourceConfiguration.buildFrom(mapper, ignoreFieldsWrapper);
        fields = new FieldsWrapper(context, element);
        mappingRegistry.fields(fields);

        if (registry.contains(origClasse)) {
            return;
        }

        // Here we collect custom mappers
        //collectCustom(mapper);
        customMappers = new CustomMapperWrapper(element, context);
        mappingRegistry.customMappers(customMappers);

        collectEnums(mapper);
        validateTypes();
    }

    private void collectEnums(AnnotationWrapper mapper) {

        for (AnnotationWrapper enumMapper : mapper.getAsAnnotationWrapper("withEnums")) {
            mappingRegistry.pushCustomEnumMapper(enumMapper);
        }
    }

    /*private void collectCustom(AnnotationWrapper annotationWrapper) {


        if (annotationWrapper.getAsStrings("withCustom").size() > 0) {
            int mappingMethodCount = 0;

            for (String customMapper : annotationWrapper.getAsStrings("withCustom")) {

                final TypeElement element = context.elements.getTypeElement(customMapper.replace(".class", ""));

                final String potentialMapper = String.format(CUSTOM_MAPPER_FIELD_TPL, element.getSimpleName());

                final List<ExecutableElement> methods = ElementFilter.methodsIn(element.getEnclosedElements());

                for (ExecutableElement method : methods) {
                    MethodWrapper methodWrapper = new MethodWrapper(method, context);
                    if (isValidCustomMapping(methodWrapper)) {
                        context.info(method, "Found an elligible custom mapping method ...");


                        if (methodWrapper.isCustomMapper()) {
                            mappingRegistry.pushCustomMapper(potentialMapper, methodWrapper);
                        } else {
                            mappingRegistry.pushMappingInterceptor(potentialMapper, methodWrapper);
                        }
                        mappingMethodCount++;
                    }
                }

                if (mappingMethodCount == 0) {
                    context.error(element, "No valid mapping method found in custom selma class %s\\n A custom mapping method is public static returns a type not void and takes two parameter (bean to convert and factory for instantiation).", customMapper);
                } else {

                    List<ExecutableElement> constructors = ElementFilter.constructorsIn(element.getEnclosedElements());
                    int defaultConstructorCount = 0;
                    for (ExecutableElement constructor : constructors) {
                        if (constructor.getParameters().size() == 0 && constructor.getModifiers().contains(PUBLIC)) {
                            defaultConstructorCount++;
                        }
                    }
                    if (defaultConstructorCount <= 0) {
                        context.error(element, "No default public constructor found in custom mapping class %s\\n Please add one", customMapper);
                    }

                    // Here we collect the name of the field to create in the Mapper generated class
                    customMaperFields.add(element);
                }
            }
        }/*private boolean isValidCustomMapping(MethodWrapper methodWrapper) {
        boolean res = true;

        if (MapperProcessor.exclusions.contains(methodWrapper.getSimpleName())) {
            // We skip excluded methods
            return false;
        }

        if (!methodWrapper.element().getModifiers().contains(javax.lang.model.element.Modifier.PUBLIC)) {
            context.warn(methodWrapper.element(), "Custom mapping method should be *public* (Fix modifiers of the method) on %s", methodWrapper.getSimpleName());
            res = false;
        }

        if (methodWrapper.element().getModifiers().contains(Modifier.STATIC)) {
            context.warn(methodWrapper.element(), "Custom mapping method can not be *static* (Fix modifiers of the method) on %s", methodWrapper.getSimpleName());
            res = false;
        }

        if (methodWrapper.element().getModifiers().contains(Modifier.ABSTRACT)) {
            context.warn(methodWrapper.element(), "Custom mapping method can not be *abstract* (Fix modifiers of the method) on %s", methodWrapper.getSimpleName());
            res = false;
        }

        if (!methodWrapper.isCustomMapper() && !methodWrapper.isMappingInterceptor()) {
            context.warn(methodWrapper.element(), "Custom mapping method should have a return type and one parameter and interceptor method should be void and have two parameters (Fix method signature) on %s", methodWrapper.getSimpleName());
            res = false;
        }

        return res;
    }

    }*/


    private void validateTypes() {

        for (ExecutableElement mapperMethod : mapperMethods) {

            MethodWrapper methodWrapper = new MethodWrapper(mapperMethod, context);

            processEnumMapper(methodWrapper);

            InOutType inOutType = methodWrapper.inOutType();
            if (inOutType.differs()) {
                MappingBuilder builder = MappingBuilder.getBuilderFor(context, inOutType);

                if ((inOutType.in().getKind() != TypeKind.DECLARED || inOutType.out().getKind() != TypeKind.DECLARED) && builder == null) {
                    context.error(mapperMethod, "In type : %s and Out type : %s differs and this kind of conversion is not supported here", inOutType.in(), inOutType.out());
                } else {
                    context.mappingMethod(methodWrapper.inOutType(), methodWrapper.getSimpleName());
                }
            }

        }
    }

    private void processEnumMapper(MethodWrapper methodWrapper) {
        if (methodWrapper.hasEnumMapper()) {

            TypeMirror enumOut = methodWrapper.returnType();
            TypeMirror enumIn = methodWrapper.firstParameterType();
            InOutType inOutType = new InOutType(enumIn, enumOut);

            AnnotationWrapper enumMapper = AnnotationWrapper.buildFor(context, methodWrapper.element(), EnumMapper.class);

            // when mapping is used on a method mapping one enum to another we can use these values
            if (!inOutType.areEnums()) {

                mappingRegistry.pushCustomEnumMapper(enumMapper);
            } else {
                // Use from and to in annotation
                mappingRegistry.pushCustomEnumMapper(inOutType, enumMapper);
            }

        }

    }

    public void build() throws IOException {

        if (registry.contains(origClasse))
            return;

        registry.add(origClasse);

        boolean firstMethod = true;
        JavaWriter writer = null;
        JavaFileObject sourceFile = null;

        for (ExecutableElement mapperMethod : mapperMethods) {

            if (firstMethod) {
                String packageName = getPackage(mapperMethod).getQualifiedName().toString();
                TypeElement type = processingEnv.getElementUtils().getTypeElement(origClasse);
                String strippedTypeName = strippedTypeName(type.getQualifiedName().toString(), packageName);
                String adapterName = new StringBuilder(type.toString()).append(SelmaConstants.MAPPER_CLASS_SUFFIX).toString();

                sourceFile = processingEnv.getFiler().createSourceFile(adapterName, type);
                writer = new JavaWriter(sourceFile.openWriter());

                writer.emitSingleLineComment(GENERATED_BY_SELMA);
                writer.emitPackage(packageName);
                writer.emitEmptyLine();
                if (configuration.isFinalMappers()) {
                    writer.beginType(adapterName, "class", EnumSet.of(PUBLIC, FINAL), null, strippedTypeName);
                } else {
                    writer.beginType(adapterName, "class", EnumSet.of(PUBLIC), null, strippedTypeName);
                }
                writer.emitEmptyLine();
                firstMethod = false;

                buildConstructor(writer, adapterName);
            }
            // Write mapping method
            MapperMethodGenerator.create(writer, mapperMethod, context, mappingRegistry, configuration).build();

            writer.emitEmptyLine();
        }
        writer.endType();
        writer.close();

        customMappers.reportUnused();

        // Report unused ignore fields
        ignoreFieldsWrapper.reportUnusedFields();

        // Report unused custom fields mapping
        fields.reportUnused();
    }

    private void buildConstructor(JavaWriter writer, String adapterName) throws IOException {


        int i = 0, iArg = 0;
        String[] args = new String[configuration.getSourceClass().size() * 2];
        List<String> assigns = new ArrayList<String>();
        StringBuilder builder = new StringBuilder();
        for (String classe : configuration.getSourceClass()) {

            builder.append(',');
            writer.emitEmptyLine();
            writer.emitJavadoc("This field is used as source akka given as parameter to the Pojos constructors");
            writer.emitField(classe.replace(".class", ""), "source" + i, EnumSet.of(PRIVATE, FINAL));
            args[iArg] = classe.replace(".class", "");
            iArg++;
            args[iArg] = "_source" + i;
            iArg++;
            assigns.add(String.format("this.source%s = _source%s", i, i));
            builder.append("this.source").append(i);
        }

        customMappers.emitCustomMappersFields(writer, false);

        if (configuration.getSourceClass().size() > 0) {
            builder.deleteCharAt(0);
        }

        // newParams hold the parameters we pass to Pojo constructor
        context.setNewParams(builder.toString());

        // First build default constructor
        writer.emitEmptyLine();
        writer.emitJavadoc("Single constructor");
        writer.beginMethod(null, adapterName, EnumSet.of(PUBLIC), args);

        // assign source in parameters to instance fields
        for (String assign : assigns) {
            writer.emitStatement(assign);
        }
        // Add customMapper instantiation
        customMappers.emitCustomMappersFields(writer, true);

        writer.endMethod();
        writer.emitEmptyLine();
    }

/*
    private void emitCustomMappersFields(JavaWriter writer, boolean assign) throws IOException {
        for (TypeElement customMaperField : customMaperFields) {
            final String field = String.format(CUSTOM_MAPPER_FIELD_TPL, customMaperField.getSimpleName().toString());
            if (assign) {
                // assign the customMapper field to a newly created instance passing to it the declared source params
                writer.emitStatement("this.%s = new %s(%s)", field, customMaperField.getQualifiedName().toString(), context.newParams());
            } else {
                writer.emitEmptyLine();
                writer.emitJavadoc("This field is used for custom Mapping");
                writer.emitField(customMaperField.asType().toString(), String.format(CUSTOM_MAPPER_FIELD_TPL, customMaperField.getSimpleName().toString()), EnumSet.of(PRIVATE));

                writer.emitEmptyLine();
                writer.emitJavadoc("Custom Mapper setter for " + field);
                writer.beginMethod("void", "setCustomMapper" + customMaperField.getSimpleName(), EnumSet.of(PUBLIC, FINAL), customMaperField.asType().toString(), "mapper");
                writer.emitStatement("this.%s = mapper", field);
                writer.endMethod();
                writer.emitEmptyLine();
            }
        }
    }
*/

    public PackageElement getPackage(Element type) {
        while (type.getKind() != ElementKind.PACKAGE) {
            type = type.getEnclosingElement();
        }
        return (PackageElement) type;
    }

    public String strippedTypeName(String type, String packageName) {
        return type.substring(packageName.isEmpty() ? 0 : packageName.length() + 1);
    }

}
